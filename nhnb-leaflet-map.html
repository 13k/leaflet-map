<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="nhnb-leaflet-import.html">


<!--
Element which defines an icon template for markers (<a href="http://leafletjs.com/reference.html#icon">Leaflet Reference</a>).

##### Example

    <nhnb-leaflet-icon id="myicon"
    	iconurl="https://stendhalgame.org/images/mapmarker/me.png">
    </nhnb-leaflet-icon>

@element nhnb-leaflet-icon
@blurb element which defines an icon template for markers.
@status beta
@homepage https://nhnb.github.io/nhnb-leaflet-map/
-->
<polymer-element name="nhnb-leaflet-icon" attributes="iconurl iconretinaurl iconwith iconheight iconanchorx iconanchory shadowurl shadowretinaurl shadowwidth shadowheight shadowanchorx shadowanchory popupanchorx popupanchory classname">
	<template>
		<style>
			:host {
				display: none;
			}
		</style>
	</template>
	<script>
	"use strict";

	Polymer('nhnb-leaflet-icon', {

		/**
		 * The `iconurl` attribute sets the URL to the icon image (absolute or relative to your script path).
		 * 
		 * @attribute iconurl
		 * @type string 
		 */
		iconurl: undefined,

		/**
		 * The `iconretunaurl` attribute sets the URL to a retina sized version of the icon image (absolute or relative to your script path). Used for Retina screen devices.
		 * 
		 * @attribute iconretinaurl
		 * @type string
		 */
		iconretinaurl: undefined,

		/**
		 * The `iconwith` attribute sets the size of the icon image in pixels. 
		 * 
		 * @attribute iconwidth
		 * @type number
		 */
		iconwith: undefined,

		/**
		 * The `iconheight` attribute sets the size of the icon image in pixels.
		 * 
		 * @attribute iconheight
		 * @type number
		 */
		iconheight: undefined,

		/**
		 * The `iconanchorx` attribute sets the coordinates of the "tip" of the icon (relative to its top left corner). The icon will be aligned so that this point is at the marker's geographical location. Centered by default if size is specified, also can be set in CSS with negative margins.
		 * 
		 * @attribute iconanchorx
		 * @type number
		 */
		iconanchorx: undefined,

		/**
		 * The `iconanchory` attribute sets the coordinates of the "tip" of the icon (relative to its top left corner). The icon will be aligned so that this point is at the marker's geographical location. Centered by default if size is specified, also can be set in CSS with negative margins.
		 * 
		 * @attribute iconanchory
		 * @type number
		 */
		iconanchory: undefined,

		/**
		 * The `shadowurl` attribute sets the URL to the icon shadow image. If not specified, no shadow image will be created.
		 * 
		 * @attribute shadowurl
		 * @type string
		 */
		shadowurl: undefined,

		/**
		 * The `shadowretinaurl` attribute sets the URL to the retina sized version of the icon shadow image. If not specified, no shadow image will be created. Used for Retina screen devices.
		 * 
		 * @attribute shadowretinaurl
		 * @type string
		 */
		shadowretinaurl: undefined,

		/**
		 * The `shadowwidth` attribute sets the size of the shadow image in pixels.
		 * 
		 * @attribute shadowwidth
		 * @type number
		 */
		shadowwidth: undefined,

		/**
		 * The `shadowheight` attribute sets the size of the shadow image in pixels.
		 * 
		 * @attribute shadowheight
		 * @type number
		 */
		shadowheight: undefined,

		/**
		 * The `shadowanchorx` attribute sets the coordinates of the "tip" of the shadow (relative to its top left corner) (the same as iconAnchor if not specified).
		 * 
		 * @attribute shadowanchorx
		 * @type number
		 */
		shadowanchorx: undefined,

		/**
		 * The `shadowanchory` attribute sets the coordinates of the "tip" of the shadow (relative to its top left corner) (the same as iconAnchor if not specified).
		 * 
		 * @attribute shadowanchory
		 * @type number
		 */
		shadowanchory: undefined,

		/**
		 * The `popupanchorx` attribute sets the coordinates of the point from which popups will "open", relative to the icon anchor.
		 * 
		 * @attribute popupanchorx
		 * @type number
		 */
		popupanchorx: undefined,

		/**
		 * The `popupanchory` attribute sets the coordinates of the point from which popups will "open", relative to the icon anchor.
		 * 
		 * @attribute popupanchory
		 * @type number
		 */
		popupanchory: undefined,

		/**
		 * The `classname` attribute sets a custom class name to assign to both icon and shadow images. Empty by default.
		 * 
		 * @attribute classname
		 * @type string
		 */
		classname: "",
		

		icon_: null,

		getIcon: function() {
			if (this.icon_) {
				return this.icon_;
			}
			var icon = {
				iconUrl: this.iconurl,
				iconRetinaUrl: this.iconretinaurl,
				shadowUrl: this.shadowurl,
				shadowRetinaUrl: this.shadowretinaurl,
				className: this.classname	
			};
			if (this.iconwidth && this.iconheight) {
				icon.iconSize = L.point(this.iconwith, this.iconheight);
			}
			if (this.iconanchorx && this.iconanchory) {
				icon.iconAnchor = L.point(this.iconanchorx, this.iconanchory);
			}
			if (this.shadowwidth && this.shadowheight) {
				icon.shadowSize = L.point(this.shadowwith, this.shadowheight);
			}
			if (this.shadowanchorx && this.shadowanchory) {
				icon.shadowAnchor = L.point(this.shadowanchorx, this.shadowanchory);
			}
			if (this.popupanchorx && this.popupanchory) {
				icon.popupAnchor = L.point(this.popupanchorx, this.popupanchory);
			}
			
			this.icon_ = L.icon(icon);
			return this.icon_;
		},
		
		attributeChanged: function() {
			this.icon_ = null;
		}
	});
	</script>
</polymer-element>






<!--
Element which defines an divicon template for markers (<a href="http://leafletjs.com/reference.html#divicon">Leaflet Reference</a>).

##### Example

    <nhnb-leaflet-divicon id="myicon" classname="name">
    	<a href="https://nhnb.github.io/nhnb-leaflet-map/demo.html">Demo</a>
    </nhnb-leaflet-icon>

@element nhnb-leaflet-divicon
@blurb element which defines an divicon template for markers.
@status beta
@homepage https://nhnb.github.io/nhnb-leaflet-map/
-->
<polymer-element name="nhnb-leaflet-divicon" attributes="iconwith iconheight iconanchorx iconanchory classname">
	<template>
		<style>
			:host {
				display: none;
			}
		</style>
	</template>
	<script>
	"use strict";

	Polymer('nhnb-leaflet-divicon', {

		/**
		 * The `iconwith` attribute sets the size of the icon image in pixels. 
		 * 
		 * @attribute iconwidth
		 * @type number
		 */
		iconwith: undefined,

		/**
		 * The `iconheight` attribute sets the size of the icon image in pixels. 
		 * 
		 * @attribute iconheight
		 * @type number
		 */
		iconheight: undefined,

		/**
		 * The `iconanchorx` attribute sets the coordinates of the "tip" of the icon (relative to its top left corner). The icon will be aligned so that this point is at the marker's geographical location. Centered by default if size is specified, also can be set in CSS with negative margins.
		 * 
		 * @attribute iconanchorx
		 * @type number
		 */
		iconanchorx: undefined,

		/**
		 * The `iconanchory` attribute sets the coordinates of the "tip" of the icon (relative to its top left corner). The icon will be aligned so that this point is at the marker's geographical location. Centered by default if size is specified, also can be set in CSS with negative margins.
		 * 
		 * @attribute iconanchory
		 * @type number
		 */
		iconanchory: undefined,

		/**
		 * The `classname` attribute sets a custom class name to assign to both icon and shadow images. Empty by default.
		 * 
		 * @attribute classname
		 * @type string
		 */
		classname: "",


		icon_: null,

		getIcon: function() {
			if (this.icon_) {
				return this.icon_;
			}
			var icon = {
				className: this.classname,
				html: this.innerHTML
			};
			if (this.iconwidth && this.iconheight) {
				icon.iconSize = L.point(this.iconwith, this.iconheight);
			}
			if (this.iconanchorx && this.iconanchory) {
				icon.iconAnchor = L.point(this.iconanchorx, this.iconanchory);
			}
			
			this.icon_ = L.divicon(icon);
			return this.icon_;
		},

		attributeChanged: function() {
			this.icon_ = null;
		}
	});
	</script>
</polymer-element>









<!--
Element which defines a maker  (<a href="http://leafletjs.com/reference.html#marker">Leaflet Reference</a>).

##### Example

	<nhnb-leaflet-marker latitude="51.5" longitude="-0.10" title="Some title">
		<b>Popup text</b>
	</nhnb-leaflet-marker>

##### Example

	<nhnb-leaflet-icon id="myicon" iconurl="https://stendhalgame.org/images/mapmarker/me.png"></nhnb-leaflet-icon>

	<nhnb-leaflet-marker latitude="51.5" longitude="-0.10" title="Some title" icon="myicon">
	</nhnb-leaflet-marker>

@element nhnb-leaflet-marker
@blurb element which defines a marker. The content is used as popup window, unless it is empty.
@status beta
@homepage https://nhnb.github.io/nhnb-leaflet-map/
-->
<polymer-element name="nhnb-leaflet-marker" attributes="latitude longitude icon clickable dragable keyboard title alt zindexoffset opacity riseonhover riseoffset">
	<template>
		<style>
			:host {
				display: none;
			}
		</style>
	</template>
	<script>
	"use strict";

	Polymer('nhnb-leaflet-marker', {
		/**
		 * Fired when the user clicks (or taps) the marker.
		 * 
		 * @event click
		 * @type MouseEvent
		 * @param {LatLng} latlng The geographical point where the mouse event occured.
		 * @param {Point} layerPoint Pixel coordinates of the point where the mouse event occured relative to the map layer.
		 * @param {Point} containerPoint Pixel coordinates of the point where the mouse event occured relative to the map —Åontainer.
		 * @param {DOMMouseEvent} originalEvent The original DOM mouse event fired by the browser.
		 */

		/**
		 * Fired when the user double-clicks (or double-taps) the marker.
		 * 
		 * @event dblclick
		 * @type MouseEvent
		 * @param {LatLng} latlng The geographical point where the mouse event occured.
		 * @param {Point} layerPoint Pixel coordinates of the point where the mouse event occured relative to the map layer.
		 * @param {Point} containerPoint Pixel coordinates of the point where the mouse event occured relative to the map —Åontainer.
		 * @param {DOMMouseEvent} originalEvent The original DOM mouse event fired by the browser.
		 */

		/**
		 * Fired when the user pushes the mouse button on the marker.
		 * 
		 * @event mousedown
		 * @type MouseEvent
		 * @param {LatLng} latlng The geographical point where the mouse event occured.
		 * @param {Point} layerPoint Pixel coordinates of the point where the mouse event occured relative to the map layer.
		 * @param {Point} containerPoint Pixel coordinates of the point where the mouse event occured relative to the map —Åontainer.
		 * @param {DOMMouseEvent} originalEvent The original DOM mouse event fired by the browser.
		 */

		/**
		 * Fired when the mouse enters the marker.
		 * 
		 * @event mouseover
		 * @type MouseEvent
		 * @param {LatLng} latlng The geographical point where the mouse event occured.
		 * @param {Point} layerPoint Pixel coordinates of the point where the mouse event occured relative to the map layer.
		 * @param {Point} containerPoint Pixel coordinates of the point where the mouse event occured relative to the map —Åontainer.
		 * @param {DOMMouseEvent} originalEvent The original DOM mouse event fired by the browser.
		 */
		
		/**
		 * Fired when the mouse leaves the marker.
		 * 
		 * @event mouseout
		 * @type MouseEvent
		 * @param {LatLng} latlng The geographical point where the mouse event occured.
		 * @param {Point} layerPoint Pixel coordinates of the point where the mouse event occured relative to the map layer.
		 * @param {Point} containerPoint Pixel coordinates of the point where the mouse event occured relative to the map —Åontainer.
		 * @param {DOMMouseEvent} originalEvent The original DOM mouse event fired by the browser.
		 */
		
		/**
		 * Fired when the user right-clicks on the marker.
		 * 
		 * @event contextmenu
		 * @type MouseEvent
		 */

		/**
		 * Fired when the user starts dragging the marker.
		 * 
		 * @event dragstart
		 */

		/**
		 * Fired repeatedly while the user drags the marker.
		 * 
		 * @event drag
		 */

		/**
		 * Fired when the user stops dragging the marker.
		 * 
		 * @event dragend
		 * @type DragEndEvent
		 * @param {number} distance The distance in pixels the draggable element was moved by.
		 */

		/**
		 * Fired when the marker is moved via setLatLng. New coordinate include in event arguments.
		 * 
		 * @event move
		 * @type 
		 */

		/**
		 * Fired when the marker is added to the map.
		 * 
		 * @event add
		 * @type 
		 */

		/**
		 * Fired when the marker is removed from the map.
		 * 
		 * @event remove
		 */

		/**
		 * Fired when a popup bound to the marker is open.
		 * 
		 * @event popupopen
		 * @type PopupEvent
		 * @param {Popup} popup The popup that was opened or closed.
		 */

		 /**
		 * Fired when a popup bound to the marker is closed.
		 * 
		 * @event popupclose
		 * @type PopupEvent
		 * @param {Popup} popup The popup that was opened or closed.
		 */

		publish: {
			/**
			 * The `latitude` attribute sets the positions of the marker.
			 *
			 * @attribute latitude
			 * @type number
			 */
			latitude: {value: null, reflect: true},

			/**
			 * The `longitude` attribute sets the positions of the marker.
			 *
			 * @attribute longitude
			 * @type number
			 */
			longitude: {value: null, reflect: true}
		},

		/**
		 * The `icon` attribute sets the Icon class to use for rendering the marker. 
		 * This attribute may be refer to an id-attribute of an nhnb-leaflet-icon-element,
		 * contain json syntax or it be assigned an instance of L.icon.
		 * See Icon documentation for details on how to customize the marker icon. Set to new L.Icon.Default() by default.
		 * 
		 * @attribute icon
		 * @type string, json or L.icon
		 */
		icon: undefined,

		/**
		 * If `clickable` attribute is set to false, the marker will not emit mouse events and will act as a part of the underlying map.
		 * 
		 * @attribute clickable
		 * @type bool
		 */
		clickable: true,

		/**
		 * The `dragable` attribute sets the whether the marker is draggable with mouse/touch or not.
		 * 
		 * @attribute dragable
		 * @type bool
		 */
		dragable: false,

		/**
		 * The `keyboard` attribute sets the whether the marker is draggable with mouse/touch or not.
		 * 
		 * @attribute dragable
		 * @type bool
		 */
		 keyboard: true,

		/**
		 * The `title` attribute sets the text for the browser tooltip that appear on marker hover (no tooltip by default).
		 * 
		 * @attribute title
		 * @type string
		 */
		title: '',

		/**
		 * The `alt` attribute sets the text for the alt attribute of the icon image (useful for accessibility).
		 * 
		 * @attribute alt
		 * @type string
		 */
		alt: '',

		/**
		 * The `zindexoffset` attribute sets the zIndexOffset. By default, marker images zIndex is set automatically based on its latitude
		 * 
		 * @attribute zindexoffset
		 * @type number
		 */
		zindexoffset: 0,

		/**
		 * The `opacity` attribute sets the opacity of the marker.
		 * 
		 * @attribute opacity
		 * @type number
		 */
		opacity: 1.0,

		/**
		 * The `riseonhover` attribute sets the whether the marker will get on top of others when you hover the mouse over it. 
		 * 
		 * @attribute riseonhover
		 * @type bool
		 */
		riseonhover: false,

		/**
		 * The `riseoffset` attribute sets the z-index offset used for the riseOnHover feature.
		 * 
		 * @attribute riseoffset
		 * @type number
		 */
		riseoffset: 250,

		marker: undefined,
		
		observer_: undefined,

		observe: {
			latitude: 'positionChanged',
			longitude: 'positionChanged',
		},

		mapChanged: function() {
			if (this.map) {

				var marker = L.marker([this.latitude, this.longitude], {
					clickable: this.clickable,
					dragable: this.dragable,
					keyboard: this.keyboard,
					title: this.title,
					alt: this.alt,
					zindexoffset: this.zindexoffset,
					opacity: this.opacity,
					riseonhover: this.riseonhover,
					riseoffset: this.riseoffset,
				});
				this.marker = marker;
				this.iconChanged();

				// forward events
				marker.on('click dblclick mousedown mouseover mouseout contextmenu dragstart drag dragend move add remove popupopen popupclose', function(e) {
					this.fire(e.type, e);
				}, this);

				// update popup on content changes
				this.childrenMutated();
				if (MutationObserver && !this.observer_) {
				    this.observer_ = new MutationObserver(this.childrenMutated.bind(this));
				    this.observer_.observe(this, {childList: true, characterData: true, attributes: true, subtree: true});
				}
				this.marker.addTo(this.map);
			}
		},

		iconChanged: function() {
			// icon support
			var iconOption;
			if (this.icon) {
				if (typeof this.icon == "string") {
					var iconElement = document.getElementById(this.icon);
					if (iconElement != null) {
						if (iconElement.getIcon) {
							iconOption = iconElement.getIcon();
						}
					} else {
						try {
							iconOption = L.icon(JSON.parse(this.icon));
						} catch (e) {
							iconOption = new L.Icon.Default();
						}
					}
				} else {
					iconOption = this.icon;
				}
			}
			if (!iconOption) {
				iconOption = new L.Icon.Default();
			}
			if (this.marker) {
				this.marker.setIcon(iconOption);
			}
		},

		positionChanged: function() {
			if (this.marker) {
				this.marker.setLatLng(L.LatLng(this.latitude, this.longitude));
			}
		},

		zindexoffsetChanged: function() {
			if (this.marker) {
				this.marker.setZIndexOffset(this.zindex);
			}
		},

		opacityChanged: function() {
			if (this.marker) {
				this.marker.setOpacity(this.opacity);
			}
		},
		
		childrenMutated: function() {
			this.marker.unbindPopup();
			if (this.innerHTML.trim()) {
				this.marker.bindPopup(this.innerHTML);
			}
		},
		
		detached: function() {
			if (this.map && this.marker) {
				this.map.removeLayer(this.marker);
			}
			if (observer_) {
				observer.disconnect();
			}
		}

	});
	</script>
</polymer-element>



<!--
element which defines a tile layer (<a href="http://leafletjs.com/reference.html#tileLayer">Leaflet Reference</a>).

##### Example

	<nhnb-leaflet-tilelayer 
		url="https://stendhalgame.org/map/3/{z}-{x}-{y}.png"
		minzoom="2" maxzoom="6" nowrap>

			Map source: <a href="https://stendhalgame.org">Stendhal MMORPG</a>

	</nhnb-leaflet-tilelayer>

@element nhnb-leaflet-tilelayer
@blurb element which defines a tile layer. The content of the nhnb-leaflet-tilelayer is used as attribution. 
@status beta
@homepage https://nhnb.github.io/nhnb-leaflet-map/
-->

<polymer-element name="nhnb-leaflet-tilelayer" attributes="url minzoom maxzoom nowrap maxnativezoom tilesize subdomains errortileurl attribution tms continuous-world nowrap zoomoffset zoomreverse opacity zindex detectretina reusetiles">
	<template>
		<style>
			:host {
				display: none;
			}
		</style>
	</template>
	<script>
	"use strict";

	Polymer('nhnb-leaflet-tilelayer', {
		/**
		 * Fired when the tile layer starts loading tiles.
		 * 
		 * @event loading
		 */

		/**
		 * Fired when the tile layer loaded all visible tiles.
		 * 
		 * @event load
		 */

		/**
		 * Fired when a tile is requested and starts loading.
		 * 
		 * @event tileloadstart
		 * @type TileEvent
		 * @param {HTMLElement} tile The tile element (image).
		 * @param {string} url The source URL of the tile.
		 */

		/**
		 * Fired when a tile loads.
		 * 
		 * @event tileload
		 * @type TileEvent
		 * @param {HTMLElement} tile The tile element (image).
		 * @param {string} url The source URL of the tile.
		 */

		/**
		 * Fired when a tile is removed (e.g. when you have unloadInvisibleTiles on).
		 * 
		 * @event tileunload
		 * @type TileEvent
		 * @param {HTMLElement} tile The tile element (image).
		 * @param {string} url The source URL of the tile.
		 */

		/**
		 * The `url` attribute sets the address template for tilesets.
		 *
		 *	 'http://{s}.somedomain.com/blabla/{z}/{x}/{y}.png'
		 *
		 * {s} means one of the available subdomains (used sequentially to help with 
		 * browser parallel requests per domain limitation; subdomain values are specified
		 * in options; a, b or c by default, can be omitted), {z} ‚Äî zoom level, {x} and {y}
		 * ‚Äî tile coordinates. 
		 * 
		 * @attribute url
		 * @type string
		 */
		url: "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",

		/**
		 * The `minzoom` attribute sets the minimum zoom number.
		 * 
		 * @attribute minzoom
		 * @type number
		 */
		minzoom: 0,

		/**
		 * The `maxzoom` attribute sets the maximum zoom number.
		 * 
		 * @attribute maxzoom
		 * @type number
		 */
		maxzoom: 18,

		/**
		 * The `maxnativezoom` attribute sets the maximum zoom number the tiles source has available. If it is specified, the tiles on all zoom levels higher than maxNativeZoom will be loaded from maxZoom level and auto-scaled. 
		 * 
		 * @attribute maxnativezoom
		 * @type number
		 */
		maxnativezoom: null,

		/**
		 * The `tilesize` attribute sets the tile size (width and height in pixels, assuming tiles are square).
		 * 
		 * @attribute tilesize
		 * @type number
		 */
		tilesize: 256,

		/**
		 * The `subdomains` attribute sets the subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
		 * 
		 * @attribute subdomains
		 * @type string or string[]
		 */
		subdomains: "abc",

		/**
		 * The `errortileurl` attribute sets the URL to the tile image to show in place of the tile that failed to load.
		 * 
		 * @attribute errortileurl
		 * @type string
		 */
		errortileurl: "",

		/**
		 * The `attribution` attribute sets the attribute. As html code needs to be escaped here, it is preferable to define it as child element.
		 * 
		 * @attribute attribution
		 * @type 
		 */
		attribution: "",

		/**
		 * The `tms` attribute sets wether inverses Y axis numbering for tiles should be used (turn this on for TMS services).
		 * 
		 * @attribute tms
		 * @type bool
		 */
		tms: false,

		/**
		 * The `continuousworld` attribute sets the wether tile coordinates won't be wrapped by world width (-180 to 180 longitude) or clamped to lie within world height (-90 to 90). Use this if you use Leaflet for maps that don't reflect the real world (e.g. game, indoor or photo maps).
		 * 
		 * @attribute continuousworld
		 * @type bool
		 */
		continuousworld: false,

		/**
		 * The `nowrap` attribute sets wether the tiles just won't load outside the world width (-180 to 180 longitude) instead of repeating.
		 * 
		 * @attribute nowrap
		 * @type bool
		 */
		nowrap: false,

		/**
		 * The `zoomoffset` attribute sets the zoom number used in tile URLs will be offset with this value.
		 * 
		 * @attribute zoomoffset
		 * @type number
		 */
		zoomoffset: 0,

		/**
		 * The `zoomreverse` attribute sets whether the zoom number used in tile URLs will be reversed (maxZoom - zoom instead of zoom)
		 * 
		 * @attribute zoomreverse
		 * @type bool
		 */
		zoomreverse: false,

		/**
		 * The `opacity` attribute sets the opacity of the tile layer.
		 * 
		 * @attribute opacity
		 * @type number
		 */
		opacity: 1.0,

		/**
		 * The `zindex` attribute sets the explicit zIndex of the tile layer. Not set by default.
		 * 
		 * @attribute zindex
		 * @type number
		 */
		zindex: null,

		/**
		 * The `detectretina` attribute sets whether if user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution. 
		 * 
		 * @attribute detectretina
		 * @type bool
		 */
		detectretina: false,

		/**
		 * The `reusetiles` attribute sets whether all the tiles that are not visible after panning are placed in a reuse queue from which they will be fetched when new tiles become visible (as opposed to dynamically creating new ones). This will in theory keep memory usage low and eliminate the need for reserving new memory whenever a new tile is needed. 
		 * 
		 * @attribute reusetiles
		 * @type bool
		 */
		reusetiles: false,

		// unloadInvisibleTiles updateWhenIdle bounds
		
		mapChanged: function() {
			if (this.map) {
				var layer = L.tileLayer(this.url, {
					attribution: this.innerHTML + this.attribution,
					minZoom: this.minzoom,
					maxZoom: this.maxzoom,
					maxNativeZoom: this.maxnativezoom,
					tileSize: this.tilesize,
					subdomains: this.subdomains,
					errorTileUrl: this.errortileurl,
					tms: this.tms,
					continuousWorld: this.continuousworld,
					noWrap: this.nowrap,
					zoomOffset: this.zoomoffset,
					zoomReverse: this.zoomreverse,
					opacity: this.opacity,
					zIndex: this.zindex,
					detectRetina: this.detectretina,
					reuseTiles: this.reusetiles,
				});
				this.layer = layer

				// forward events
				layer.on('loading load tileloadstart tileload tileunload', function(e) {
					this.fire(e.type, e);
				}, this);
				this.layer.addTo(this.map);
			}
		},

		opacityChanged: function() {
			if (this.layer) {
				this.layer.setOpacity(this.opacity);
			}
		},
		zindexChanged: function() {
			if (this.layer) {
				this.layer.setZIndex(this.zindex);
			}
		},
		urlChanged: function() {
			if (this.layer) {
				this.layer.setUrl(this.url);
			}
		},

		detached: function() {
			if (this.map && this.layer) {
				this.map.removeLayer(this.layer);
			}
		}
	});
	</script>
</polymer-element>






<!--
element which defines a leadlet map (<a href="http://leafletjs.com/reference.html#map">Leaflet Reference</a>).

##### Example

	<nhnb-leaflet-map> </nhnb-leaflet-map>
	
##### Example
	
	<nhnb-leaflet-map latitude="78.8" longitude="-96" zoom="5">
		<nhnb-leaflet-marker latitude="51.5" longitude="-0.10" title="Some title">
			<b>Popup text</b>
		</nhnb-leaflet-marker>
	
	</nhnb-leaflet-map>  

@element nhnb-leaflet-map
@blurb element which defines a leaflet map. Most options are supported as attributes. 
@status beta
@homepage https://nhnb.github.io/nhnb-leaflet-map/
-->
<polymer-element name="nhnb-leaflet-map" attributes="minzoom maxzoom dragging touchzoom scrollwheelzoom doubleclickzoom boxzoom tap taptolerance trackresize worldcopyjump closepopuponclick bounceatzoomlimits keyboard keyboardpanoffset keyboardzoomoffset inertia inertiadeceleration inertiamaxspeed zoomcontrol attributioncontrol zoomanimationthreshold">
	<template>
		<link rel="stylesheet" href="../leaflet-bower/dist/leaflet.css" />
		<style>
			:host { display: block; } 
			:host #map {height:100%; width:100%}
		</style>
		<div id="map"></div>
		<content id="markers" select="*"></content>
  	</template>
	<script>
	"use strict";

	Polymer('nhnb-leaflet-map', {
		/**
		 * Fired when the user clicks (or taps) the marker.
		 * 
		 * @event click
		 * @type MouseEvent
		 * @param {LatLng} latlng The geographical point where the mouse event occured.
		 * @param {Point} layerPoint Pixel coordinates of the point where the mouse event occured relative to the map layer.
		 * @param {Point} containerPoint Pixel coordinates of the point where the mouse event occured relative to the map —Åontainer.
		 * @param {DOMMouseEvent} originalEvent The original DOM mouse event fired by the browser.
		 */

		/**
		 * Fired when the user double-clicks (or double-taps) the marker.
		 * 
		 * @event dblclick
		 * @type MouseEvent
		 * @param {LatLng} latlng The geographical point where the mouse event occured.
		 * @param {Point} layerPoint Pixel coordinates of the point where the mouse event occured relative to the map layer.
		 * @param {Point} containerPoint Pixel coordinates of the point where the mouse event occured relative to the map —Åontainer.
		 * @param {DOMMouseEvent} originalEvent The original DOM mouse event fired by the browser.
		 */

		/**
		 * Fired when the user pushes the mouse button on the marker.
		 * 
		 * @event mousedown
		 * @type MouseEvent
		 * @param {LatLng} latlng The geographical point where the mouse event occured.
		 * @param {Point} layerPoint Pixel coordinates of the point where the mouse event occured relative to the map layer.
		 * @param {Point} containerPoint Pixel coordinates of the point where the mouse event occured relative to the map —Åontainer.
		 * @param {DOMMouseEvent} originalEvent The original DOM mouse event fired by the browser.
		 */

		/**
		 * Fired when the mouse enters the marker.
		 * 
		 * @event mouseover
		 * @type MouseEvent
		 * @param {LatLng} latlng The geographical point where the mouse event occured.
		 * @param {Point} layerPoint Pixel coordinates of the point where the mouse event occured relative to the map layer.
		 * @param {Point} containerPoint Pixel coordinates of the point where the mouse event occured relative to the map —Åontainer.
		 * @param {DOMMouseEvent} originalEvent The original DOM mouse event fired by the browser.
		 */

		/**
		 * Fired when the mouse leaves the marker.
		 * 
		 * @event mouseout
		 * @type MouseEvent
		 * @param {LatLng} latlng The geographical point where the mouse event occured.
		 * @param {Point} layerPoint Pixel coordinates of the point where the mouse event occured relative to the map layer.
		 * @param {Point} containerPoint Pixel coordinates of the point where the mouse event occured relative to the map —Åontainer.
		 * @param {DOMMouseEvent} originalEvent The original DOM mouse event fired by the browser.
		 */

		/**
		 * Fired when the user right-clicks on the marker.
		 * 
		 * @event contextmenu
		 * @type MouseEvent
		 * @param {LatLng} latlng The geographical point where the mouse event occured.
		 * @param {Point} layerPoint Pixel coordinates of the point where the mouse event occured relative to the map layer.
		 * @param {Point} containerPoint Pixel coordinates of the point where the mouse event occured relative to the map —Åontainer.
		 * @param {DOMMouseEvent} originalEvent The original DOM mouse event fired by the browser.
		 */

		/**
		 * Fired when the user focuses the map either by tabbing to it or clicking/panning.
		 * 
		 * @event focus
		 */

		/**
		 * Fired when the map looses focus.
		 * 
		 * @event blur
		 */

		/**
		 * Fired before mouse click on the map (sometimes useful when you want something to happen on click before any existing click handlers start running).
		 * 
		 * @event preclick
		 * @type MouseEvent
		 * @param {LatLng} latlng The geographical point where the mouse event occured.
		 * @param {Point} layerPoint Pixel coordinates of the point where the mouse event occured relative to the map layer.
		 * @param {Point} containerPoint Pixel coordinates of the point where the mouse event occured relative to the map —Åontainer.
		 * @param {DOMMouseEvent} originalEvent The original DOM mouse event fired by the browser.
		 */

		/**
		 * Fired when the map is initialized (when its center and zoom are set for the first time).
		 * 
		 * @event load
		 */

		/**
		 * Fired when the map is destroyed with remove method.
		 * 
		 * @event unload
		 */

		/**
		 * Fired when the map needs to redraw its content (this usually happens on map zoom or load). Very useful for creating custom overlays.
		 * 
		 * @event viewreset
		 */

		/**
		 * Fired when the view of the map starts changing (e.g. user starts dragging the map).
		 * 
		 * @event movestart
		 */

		/**
		 * Fired on any movement of the map view.
		 * 
		 * @event move
		 */

		/**
		 * Fired when the view of the map ends changed (e.g. user stopped dragging the map).
		 * 
		 * @event moveend
		 */

		/**
		 * Fired when the user starts dragging the marker.
		 * 
		 * @event dragstart
		 */

		/**
		 * Fired repeatedly while the user drags the marker.
		 * 
		 * @event drag
		 */

		/**
		 * Fired when the user stops dragging the marker.
		 * 
		 * @event dragend
		 * @type DragEndEvent
		 * @param {number} distance The distance in pixels the draggable element was moved by.
		 */

		/**
		 * Fired when the map zoom is about to change (e.g. before zoom animation).
		 * 
		 * @event zoomstart
		 */

		/**
		 * Fired when the map zoom changes.
		 * 
		 * @event zoomend
		 */

		/**
		 * Fired when the number of zoomlevels on the map is changed due to adding or removing a layer.
		 * 
		 * @event zoomlevelschange
		 */

		/**
		 * Fired when the map is resized.
		 * 
		 * @event resize
		 * @type ResizeEvent
		 * @param {Point}	oldSize	The old size before resize event.
		 * @param {Point}	newSize	The new size after the resize event.
		 */

		/**
		 * Fired when the map starts autopanning when opening a popup.
		 * 
		 * @event autopanstart
		 */

		/**
		 * Fired when a new layer is added to the map.
		 * 
		 * @event layeradd
		 * @type LayerEvent
		 * @param {ILayer}	layer	The layer that was added or removed.
		 */

		/**
		 * Fired when some layer is removed from the map.
		 * 
		 * @event layerremove
		 * @type LayerEvent
		 * @param {ILayer}	layer	The layer that was added or removed.
		 */

		/**
		 * Fired when the base layer is changed through the layer control.
		 * 
		 * @event baselayerchange
		 * @type LayerEvent
		 * @param {ILayer}	layer	The layer that was added or removed.
		 */

		/**
		 * Fired when an overlay is selected through the layer control.
		 * 
		 * @event overlayadd
		 * @type LayerEvent
		 * @param {ILayer}	layer	The layer that was added or removed.
		 */

		/**
		 * Fired when an overlay is deselected through the layer control.
		 * 
		 * @event overlayremove
		 * @type LayerEvent
		 * @param {ILayer}	layer	The layer that was added or removed.
		 */

		/**
		 * Fired when geolocation (using the locate method) went successfully.
		 * 
		 * @event locationfound
		 * @type LocationEvent
		 * @param {LatLng} latlng Detected geographical location of the user.
		 * @param {LatLngBounds} bounds Geographical bounds of the area user is located in (with respect to the accuracy of location).
		 * @param {Number} accuracy Accuracy of location in meters.
		 * @param {Number} altitude Height of the position above the WGS84 ellipsoid in meters.
		 * @param {Number} altitudeAccuracy Accuracy of altitude in meters.
		 * @param {Number} heading The direction of travel in degrees counting clockwise from true North.
		 * @param {Number} speed Current velocity in meters per second.
		 * @param {Number} timestamp The time when the position was acquired.
		 */

		/**
		 * Fired when geolocation (using the locate method) failed.
		 * 
		 * @event locationerror
		 * @type ErrorEvent
		 * @param {string} message Error message.
		 * @param {number} code Error code (if applicable).
		 */

		/**
		 * Fired when a popup bound to the marker is open.
		 * 
		 * @event popupopen
		 * @type PopupEvent
		 * @param {Popup} popup The popup that was opened or closed.
		 */

		 /**
		 * Fired when a popup bound to the marker is closed.
		 * 
		 * @event popupclose
		 * @type PopupEvent
		 * @param {Popup} popup The popup that was opened or closed.
		 */


		publish: {

			/**
			 * The `latitude` attribute sets the map center.
			 * 
			 * @attribute latitude
			 * @type number
			 */
			latitude: {value: 51, reflect: true},

			/**
			 * The `longitude` attribute sets the map center.
			 * 
			 * @attribute longitude
			 * @type number
			 */
			longitude: {value: 0, reflect: true},

			/**
			 * The `zoom` attribute sets the map zoom.
			 * 
			 * @attribute zoom
			 * @type number
			 */
			zoom: {value: -1, reflect: true}
		},

		/**
		 * The `minzoom` attribute sets the minimum zoom level of the map. Overrides any minZoom set on map layers.
		 * 
		 * @attribute minzoom
		 * @type number
		 */
		minzoom: 0,

		/**
		 * The `maxzoom` attribute sets the maximum zoom level of the map. This overrides any maxZoom set on map layers.
		 * 
		 * @attribute maxzoom
		 * @type number
		 */
		maxzoom: 9007199254740992,

		/**
		 * The `dragging` attribute sets whether  when he tries to pan outside the view.
		 * 
		 * @attribute dragging
		 * @type bool
		 */
		dragging: true,

		/**
		 * The `touchzoom` attribute sets whether the map can be zoomed by touch-dragging with two fingers. 
		 * 
		 * @attribute touchzoom
		 * @type bool
		 */
		touchzoom: true,

		/**
		 * The `scrollwheelzoom` attribute sets the whether the map can be zoomed by using the mouse wheel. If passed 'center', it will zoom to the center of the view regardless of where the mouse was.
		 * 
		 * @attribute scrollwheelzoom
		 * @type bool
		 */
		scrollwheelzoom: true,

		/**
		 * The `doubleclickzoom` attribute sets the whether the map can be zoomed in by double clicking on it and zoomed out by double clicking while holding shift. If passed 'center', double-click zoom will zoom to the center of the view regardless of where the mouse was.
		 * 
		 * @attribute doubleclickzoom
		 * @type bool
		 */
		doubleclickzoom: true,

		/**
		 * The `boxzoom` attribute sets the whether the map can be zoomed to a rectangular area specified by dragging the mouse while pressing shift.
		 * 
		 * @attribute boxzoom
		 * @type bool
		 */
		boxzoom: true,

		/**
		 * The `tap` attribute enables mobile hacks for supporting instant taps (fixing 200ms click delay on iOS/Android) and touch holds (fired as contextmenu events).
		 * 
		 * @attribute tap
		 * @type bool
		 */
		tap: true,

		/**
		 * The `taptolerance` attribute sets the max number of pixels a user can shift his finger during touch for it to be considered a valid tap. 
		 * 
		 * @attribute taptolerance
		 * @type number
		 */
		taptolerance: 15,

		/**
		 * The `trackresize` attribute sets whether the map automatically handles browser window resize to update itself.
		 * 
		 * @attribute trackresize
		 * @type bool
		 */
		trackresize: true,

		/**
		 * The `worldcopyjump` attribute sets whether the map tracks when you pan to another "copy" of the world and seamlessly jumps to the original one so that all overlays like markers and vector layers are still visible.
		 * 
		 * @attribute worldcopyjump
		 * @type bool
		 */
		worldcopyjump: false,

		/**
		 * The `closepopuponclick` attribute sets whether popups are closed when user clicks the map.
		 * 
		 * @attribute closepopuponclick
		 * @type bool
		 */
		closepopuponclick: true,

		/**
		 * The `bounceatzoomlimits` attribute sets whether the map to zoom beyond min/max zoom and then bounce back when pinch-zooming.
		 * 
		 * @attribute bounceatzoomlimits
		 * @type bool
		 */
		bounceatzoomlimits: true,

		/**
		 * The `keyboard` attribute sets whether the map is focusable and allows users to navigate the map with keyboard arrows and +/- keys.
		 * 
		 * @attribute keyboard
		 * @type bool
		 */
		keyboard: true,

		/**
		 * The `keyboardpanoffset` attribute sets the amount of pixels to pan when pressing an arrow key.
		 * 
		 * @attribute keyboardpanoffset
		 * @type number
		 */
		keyboardpanoffset: 80,

		/**
		 * The `keyboardzoomoffset` attribute sets the number of zoom levels to change when pressing + or - key.
		 * 
		 * @attribute keyboardzoomoffset
		 * @type number
		 */
		keyboardzoomoffset: 1,

		/**
		 * The `inertia` attribute sets whether panning of the map will have an inertia effect where the map builds momentum while dragging and continues moving in the same direction for some time. Feels especially nice on touch devices.
		 * 
		 * @attribute inertia
		 * @type 
		 */
		inertia: true,

		/**
		 * The `inertiadeceleration` attribute sets the rate with which the inertial movement slows down, in pixels/second2.
		 * 
		 * @attribute inertiadeceleration
		 * @type number
		 */
		inertiadeceleration: 3000,

		/**
		 * The `inertiamaxspeed` attribute sets the max speed of the inertial movement, in pixels/second.
		 * 
		 * @attribute inertiamaxspeed
		 * @type number
		 */
		inertiamaxspeed: 1500,

		/**
		 * The `zoomcontrol` attribute sets whether the zoom control is added to the map by default.
		 * 
		 * @attribute zoomcontrol
		 * @type bool
		 */
		zoomcontrol: true,

		/**
		 * The `attributioncontrol` attribute sets whether the attribution control is added to the map by default.
		 * 
		 * @attribute attributioncontrol
		 * @type bool
		 */
		attributioncontrol: true,

		/**
		 * The `zoomanimationthreshold` attribute sets the maximum number of zoom level differences that still use animation
		 * 
		 * @attribute zoomanimationthreshold
		 * @type number
		 */
		zoomanimationthreshold: 4,

		/** 
		 * reference to the leaflet map
		 *
		 * @property map
		 * @type L.map
		 */
		map: undefined,

		/** update view on attribute change */
		observe: {
			latitude: 'view',
		    longitude: 'view',
		    zoom: 'view'
		},

		domReady: function() {
			L.Icon.Default.imagePath = "../leaflet-bower/dist/images";
			var map = L.map(this.$.map, {
				center: [this.latitude, this.longitude],
				zoom: this.zoom,
				minZoom: this.minzoom,
				maxZoom: this.maxzoom,
				dragging: this.dragging,
				touchZoom: this.touchzoom,
				scrollWheelZoom: this.scrollwheelzoom,
				doubleClickZoom: this.doubleclickzoom,
				boxZoom: this.boxzoom,
				tap: this.tap,
				tapTolerance: this.taptolerance,
				trackResize: this.trackresize,
				worldCopyJump: this.worldcopyjump,
				closePopupOnClick: this.closepopuponclick,
				bounceAtZoomLimits: this.bounceatzoomlimits,
				keyboard: this.keyboard,
				keyboardPanOffset: this.keyboardpanoffset,
				keyboardZoomOffset: this.keyboardzoomoffset,
				inertia: this.inertia,
				inertiaDeceleration: this.inertiadeceleration,
				inertiaMaxSpeed: this.inertiamaxspeed,
				zoomControl: this.zoomcontrol,
				attributionControl: this.attributioncontrol,
				zoomAnimationThreshold: this.zoomanimationthreshold
			});
			this.map = map;

			// forward events
			map.on('click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu focus blur preclick load unload viewreset movestart move moveend dragstart drag dragend zoomstart zoomend zoomlevelschange resize autopanstart layeradd layerremove baselayerchange overlayadd overlayremove locationfound locationerror popupopen popupclose', function(e) {
				this.fire(e.type, e);
			}, this);

			// update attributes
			map.on('moveend', function(e) {
			    this.latitude = map.getCenter().lat;
			    this.longitude = map.getCenter().lng;
			}, this);
			map.on('zoomend', function(e) {
			    this.zoom = map.getZoom();
			}, this);

			if (this.zoom == -1) {
				this.map.fitWorld();
			}

			// add a default layer if there are no layers defined
			var defaultLayerRequired = true;
			for (var i = 0; i < this.children.length; i++) {
				var localName = this.children[i].localName;
				if (localName.indexOf("-layer", localName.length - 6) !== -1) {
					defaultLayerRequired = false;
				}
			}
			if (defaultLayerRequired) {
				L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
					attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery &copy; <a href="http://mapbox.com">Mapbox</a>',
					maxZoom: 18
				}).addTo(this.map);
			}
			
			this.registerMapOnChildren();
		},

		view: function(oldValue, newValue) {
			if (this.map) {
				this.map.setView(L.latLng(this.latitude, this.longitude), this.zoom);
			}
		},

		registerMapOnChildren: function() {
			for (var i = 0; i < this.children.length; i++) {
				this.children[i].map = this.map;
			}
			this.onMutation(this, this.registerMapOnChildren);
		},
	});
    </script>
</polymer-element>