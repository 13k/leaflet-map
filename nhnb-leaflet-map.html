<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="nhnb-leaflet-import.html">

<polymer-element name="nhnb-leaflet-marker" attributes="latitude longitude clickable dragable title alt zindexoffset opacity riseonhover riseoffset">
	<template>
		<style>
			:host {
				display: none;
			}
		</style>
	</template>
	<script>
	Polymer('nhnb-leaflet-marker', {
		publish: {
			latitude: {value: null, reflect: true},
			longitude: {value: null, reflect: true}
		},
		// icon
		clickable: true,
		dragable: false,
		title: '',
		alt: '',
		zindexoffset: 0,
		opacity: 1.0,
		riseonhover: false,
		riseoffset: 250,
		marker: undefined,

		observe: {
			latitude: 'positionChanged',
		    longitude: 'positionChanged',
		},

		mapChanged: function() {
			if (this.map) {
				var marker = L.marker([this.latitude, this.longitude], {
					clickable: this.clickable,
					dragable: this.dragable,
					title: this.title,
					alt: this.alt,
					zindexoffset: this.zindexoffset,
					opacity: this.opacity,
					riseonhover: this.riseonhover,
					riseoffset: this.riseoffset,
				});
				this.marker = marker;
				// forward events
				marker.on('loading load tileloadstart tileload tileunload', function(e) {
					this.fire(e.type, e);
				}, this);

				if (this.innerHTML) {
					this.marker.bindPopup(this.innerHTML);
				}
				this.marker.addTo(this.map);
			}
		},

		positionChanged: function() {
			if (this.marker) {
				this.marker.setLatLng(L.LatLng(this.latitude, this.longitude));
			}
		},

		zindexoffsetChanged: function() {
			if (this.marker) {
				this.marker.setZIndexOffset(this.zindex);
			}
		},

		opacityChanged: function() {
			if (this.marker) {
				this.marker.setOpacity(this.opacity);
			}
		},
		
		detached: function() {
			if (this.map && this.marker) {
				this.map.removeLayer(this.marker);
			}
		}

// setIcon( <Icon> icon ) 	this 	Changes the marker icon.
// setPopupContent( <String> html | <HTMLElement> el, <Popup options> options? ) 	this 	Sets an HTML content of the popup of this marker.
		
	});
	</script>
</polymer-element>



<polymer-element name="nhnb-leaflet-tile-layer" attributes="url minzoom maxzoom nowrap maxnativezoom tilesize subdomains errortileurl attribution tms continuous-world nowrap zoomoffset zoomreverse opacity zindex detectretina reusetiles">
	<template>
		<style>
			:host {
				display: none;
			}
		</style>
	</template>
	<script>
	Polymer('nhnb-leaflet-tile-layer', {
		url: "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
		minzoom: 0,
		maxzoom: 18,
		maxnativezoom: null,
		tilesize: 256,
		subdomains: "abc",
		errortileurl: "",
		attribution: "",
		tms: false,
		continuousworld: false,
		nowrap: false,
		zoomoffset: 0,
		zoomreverse: false,
		opacity: 1.0,
		zindex: null,
		detectretina: false,
		reusetiles: false,
		// unloadInvisibleTiles updateWhenIdle bounds
		
		mapChanged: function() {
			if (this.map) {
				var layer = L.tileLayer(this.url, {
					attribution: this.innerHTML + this.attribution,
					minZoom: this.minzoom,
					maxZoom: this.maxzoom,
					maxNativeZoom: this.maxnativezoom,
					tileSize: this.tilesize,
					subdomains: this.subdomains,
					errorTileUrl: this.errortileurl,
					tms: this.tms,
					continuousWorld: this.continuousworld,
					noWrap: this.nowrap,
					zoomOffset: this.zoomoffset,
					zoomReverse: this.zoomreverse,
					opacity: this.opacity,
					zIndex: this.zindex,
					detectRetina: this.detectretina,
					reuseTiles: this.reusetiles,
				});
				this.layer = layer

				// forward events
				layer.on('loading load tileloadstart tileload tileunload', function(e) {
					this.fire(e.type, e);
				}, this);
				this.layer.addTo(this.map);
			}
		},

		opacityChanged: function() {
			if (this.layer) {
				this.layer.setOpacity(this.opacity);
			}
		},
		zindexChanged: function() {
			if (this.layer) {
				this.layer.setZIndex(this.zindex);
			}
		},
		urlChanged: function() {
			if (this.layer) {
				this.layer.setUrl(this.url);
			}
		},

		detached: function() {
			if (this.map && this.layer) {
				this.map.removeLayer(this.layer);
			}
		}
	});
	</script>
</polymer-element>






<polymer-element name="nhnb-leaflet-map" attributes="minzoom maxzoom dragging touchzoom scrollwheelzoom doubleclickzoom boxzoom tap taptolerance trackresize worldcopyjump closepopuponclick bounceatzoomlimits keyboard keyboardpanoffset keyboardzoomoffset inertia inertiadeceleration inertiamaxspeed zoomcontrol attributioncontrol zoomanimationthreshold">
	<template>
		<link rel="stylesheet" href="../leaflet-bower/dist/leaflet.css" />
		<style>
			:host { display: block; } 
			:host #map {height:100%; width:100%}
		</style>
		<div id="map"></div>
		<content id="markers" select="nhnb-leaflet-marker nhnb-leaflet-tile-layer"></content>
  	</template>
	<script>
	Polymer('nhnb-leaflet-map', {
		/** Publish attributes with reflection of values to attributes */
		publish: {
			latitude: {value: 51, reflect: true},
			longitude: {value: 0, reflect: true},
			zoom: {value: -1, reflect: true}
		},
		minzoom: 0,
		maxzoom: 9007199254740992,
		dragging: true,
		touchzoom: true,
		scrollwheelzoom: true,
		doubleclickzoom: true,
		boxzoom: true,
		tap: true,
		taptolerance: 15,
		trackresize: true,
		worldcopyjump: false,
		closepopuponclick: true,
		bounceatzoomlimits: true,
		keyboard: true,
		keyboardpanoffset: 80,
		keyboardzoomoffset: 1,
		inertia: true,
		inertiadeceleration: 3000,
		inertiamaxspeed: 1500,
		zoomcontrol: true,
		attributioncontrol: true,
		zoomanimationthreshold: 4,

		/** reference to the leaflet map */
		map: undefined,

		/** update view on attribute change */
		observe: {
			latitude: 'view',
		    longitude: 'view',
		    zoom: 'view'
		},

		domReady: function() {
			L.Icon.Default.imagePath = "../leaflet-bower/dist/images";
			var map = L.map(this.$.map, {
				center: [this.latitude, this.longitude],
				zoom: this.zoom,
				minZoom: this.minzoom,
				maxZoom: this.maxzoom,
				dragging: this.dragging,
				touchZoom: this.touchzoom,
				scrollWheelZoom: this.scrollwheelzoom,
				doubleClickZoom: this.doubleclickzoom,
				boxZoom: this.boxzoom,
				tap: this.tap,
				tapTolerance: this.taptolerance,
				trackResize: this.trackresize,
				worldCopyJump: this.worldcopyjump,
				closePopupOnClick: this.closepopuponclick,
				bounceAtZoomLimits: this.bounceatzoomlimits,
				keyboard: this.keyboard,
				keyboardPanOffset: this.keyboardpanoffset,
				keyboardZoomOffset: this.keyboardzoomoffset,
				inertia: this.inertia,
				inertiaDeceleration: this.inertiadeceleration,
				inertiaMaxSpeed: this.inertiamaxspeed,
				zoomControl: this.zoomcontrol,
				attributionControl: this.attributioncontrol,
				zoomAnimationThreshold: this.zoomanimationthreshold
            });
			this.map = map;

			// forward events
			map.on('click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu focus blur preclick load unload viewreset movestart move moveend dragstart drag dragend zoomstart zoomend zoomlevelschange resize autopanstart layeradd layerremove baselayerchange overlayadd overlayremove locationfound locationerror popupopen popupclose', function(e) {
				this.fire(e.type, e);
			}, this);

			// update attributes
			map.on('moveend', function(e) {
			    this.latitude = map.getCenter().lat;
			    this.longitude = map.getCenter().lng;
			}, this);
			map.on('zoomend', function(e) {
			    this.zoom = map.getZoom();
			}, this);

			if (this.zoom == -1) {
				this.map.fitWorld();
			}

			// add a default layer if there are no layers defined
			var defaultLayerRequired = true;
			for (var i = 0; i < this.children.length; i++) {
				var localName = this.children[i].localName;
				if (localName.indexOf("-layer", localName.length - 6) !== -1) {
					defaultLayerRequired = false;
				}
			}
			if (defaultLayerRequired) {
				L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
					attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery &copy; <a href="http://mapbox.com">Mapbox</a>',
					maxZoom: 18
				}).addTo(this.map);
			}
			
			this.registerMapOnChildren();
		},

//		center 	LatLng 	null 	Initial geographical center of the map.
//		layers 	ILayer[] 	null 	Layers that will be added to the map initially.
//		maxBounds 	LatLngBounds 	null 	When this option is set, the map restricts the view to the given geographical bounds, bouncing the user back when he tries to pan outside the view. To set the restriction dynamically, use setMaxBounds method
//		crs 	CRS 	L.CRS.		EPSG3857 	Coordinate Reference System to use. Don't change this if you're not sure what it means.
//		inertiaThreshold 	Number 	depends 	Number of milliseconds that should pass between stopping the movement and releasing the mouse or touch to prevent inertial movement. 32 for touch devices and 14 for the rest by default.
//		fadeAnimation 	Boolean 	depends 	Whether the tile fade animation is enabled. By default it's enabled in all browsers that support CSS3 Transitions except Android.
//		zoomAnimation 	Boolean 	depends 	Whether the tile zoom animation is enabled. By default it's enabled in all browsers that support CSS3 Transitions except Android.
//		markerZoomAnimation 	Boolean 	depends 	Whether markers animate their zoom with the zoom animation, if disabled they will disappear for the length of the animation. By default it's enabled in all browsers that support CSS3 Transitions except Android.

		view: function(oldValue, newValue) {
			if (this.map) {
				this.map.setView(L.latLng(this.latitude, this.longitude), this.zoom);
			}
		},


		
		registerMapOnChildren: function() {
			for (var i = 0; i < this.children.length; i++) {
				this.children[i].map = this.map;
			}
			this.onMutation(this, this.registerMapOnChildren);
		},
	});
    </script>
</polymer-element>